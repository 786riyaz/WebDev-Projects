<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zen Garden Sanctuary</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(180deg, #f5f2e8 0%, #e8dcc0 30%, #d4c4a0 70%, #c4b088 100%);
            font-family: 'Times New Roman', serif;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .content-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #2c1810;
            z-index: 10;
            pointer-events: none;
        }

        .yoga-title {
            font-size: 6rem;
            font-weight: 300;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.1);
            animation: zenBreathe 20s ease-in-out infinite;
            letter-spacing: 0.5em;
            color: #3d2c1a;
            font-family: 'Times New Roman', serif;
        }

        .yoga-subtitle {
            font-size: 2rem;
            font-weight: 200;
            opacity: 0.8;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.05);
            animation: gentleFloat 15s ease-in-out infinite;
            color: #5d4c3a;
            margin-bottom: 3rem;
            font-style: italic;
        }

        .zen-quote {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            opacity: 0.7;
            color: #4d3c2a;
            animation: wisdomFade 25s ease-in-out infinite;
            text-align: center;
            line-height: 1.8;
            font-style: italic;
            max-width: 600px;
        }

        @keyframes zenBreathe {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.9;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.02);
                opacity: 1;
            }
        }

        @keyframes gentleFloat {
            0%, 100% {
                transform: translateY(0px);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-8px);
                opacity: 0.9;
            }
        }

        @keyframes wisdomFade {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.9; }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #5d4c3a;
            font-size: 1.6rem;
            z-index: 5;
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        .wind-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: 3;
        }

        .wind-line {
            position: absolute;
            width: 200px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(100,80,60,0.3), transparent);
            animation: windFlow 30s linear infinite;
        }

        .wind-line:nth-child(1) { top: 20%; animation-delay: 0s; }
        .wind-line:nth-child(2) { top: 40%; animation-delay: 10s; }
        .wind-line:nth-child(3) { top: 60%; animation-delay: 20s; }

        @keyframes windFlow {
            0% { transform: translateX(-200px); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateX(calc(100vw + 200px)); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="wind-lines">
            <div class="wind-line"></div>
            <div class="wind-line"></div>
            <div class="wind-line"></div>
        </div>
        <div class="loading">Cultivating inner stillness...</div>
        <div class="content-overlay" style="opacity: 0;" id="content">
            <h1 class="yoga-title">ZEN</h1>
            <p class="yoga-subtitle">The Art of Being Present</p>
            <div class="zen-quote">
                "In the midst of movement and chaos,<br>
                keep stillness inside of you.<br>
                The quieter you become, the more you can hear."
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let stones = [], bamboo = [], leaves = [];
        let sandRipples, water;
        let mouseX = 0, mouseY = 0;
        let time = 0;

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf5f2e8, 1000, 4000);

            // Camera setup
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(300, 400, 800);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf5f2e8, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.bias = -0.0001;
            document.getElementById('container').appendChild(renderer.domElement);

            // Setup realistic lighting
            setupRealisticLighting();
            
            // Create zen garden elements
            createSandGarden();
            createStoneArrangement();
            createBambooGrove();
            createWaterFeature();
            createFallingLeaves();

            // Event listeners
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            // Reveal content
            setTimeout(() => {
                document.querySelector('.loading').style.display = 'none';
                document.getElementById('content').style.opacity = '1';
                document.getElementById('content').style.transition = 'opacity 3s ease-in-out';
            }, 3000);
        }

        function setupRealisticLighting() {
            // Soft ambient light
            const ambientLight = new THREE.AmbientLight(0xf5f2e8, 0.6);
            scene.add(ambientLight);

            // Main sun light
            const sunLight = new THREE.DirectionalLight(0xfffbe0, 1.2);
            sunLight.position.set(500, 800, 300);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 2000;
            sunLight.shadow.camera.left = -1000;
            sunLight.shadow.camera.right = 1000;
            sunLight.shadow.camera.top = 1000;
            sunLight.shadow.camera.bottom = -1000;
            sunLight.shadow.bias = -0.0005;
            scene.add(sunLight);

            // Fill light
            const fillLight = new THREE.DirectionalLight(0xe8dcc0, 0.4);
            fillLight.position.set(-300, 400, -200);
            scene.add(fillLight);

            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-200, 200, 800);
            scene.add(rimLight);
        }

        function createSandGarden() {
            // Main sand plane
            const sandGeometry = new THREE.PlaneGeometry(1500, 1200, 100, 80);
            const sandTexture = createSandTexture();
            const sandMaterial = new THREE.MeshLambertMaterial({
                map: sandTexture,
                color: 0xede4d0
            });

            const sand = new THREE.Mesh(sandGeometry, sandMaterial);
            sand.rotation.x = -Math.PI / 2;
            sand.receiveShadow = true;
            scene.add(sand);

            // Create sand ripples
            createSandRipples();
        }

        function createSandTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base sand color
            ctx.fillStyle = '#ede4d0';
            ctx.fillRect(0, 0, 512, 512);

            // Add noise for texture
            const imageData = ctx.getImageData(0, 0, 512, 512);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
            }

            ctx.putImageData(imageData, 0, 0);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createSandRipples() {
            // Concentric circles in sand
            for (let i = 0; i < 8; i++) {
                const rippleGeometry = new THREE.TorusGeometry(100 + i * 60, 2, 8, 32);
                const rippleMaterial = new THREE.MeshLambertMaterial({
                    color: 0xd4c4a0,
                    transparent: true,
                    opacity: 0.3
                });

                const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
                ripple.rotation.x = -Math.PI / 2;
                ripple.position.y = 1;
                ripple.position.x = -200;

                scene.add(ripple);
            }

            // Parallel lines
            for (let i = 0; i < 15; i++) {
                const lineGeometry = new THREE.BoxGeometry(600, 1, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({
                    color: 0xc8b896,
                    transparent: true,
                    opacity: 0.4
                });

                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(200, 1, -300 + i * 40);

                scene.add(line);
            }
        }

        function createStoneArrangement() {
            // Large central stones
            const stonePositions = [
                { x: -200, z: -100, scale: 1.5 },
                { x: -150, z: 50, scale: 1.2 },
                { x: -100, z: -50, scale: 0.8 },
                { x: 100, z: 100, scale: 1.0 },
                { x: 150, z: -20, scale: 0.9 }
            ];

            stonePositions.forEach((pos, index) => {
                const stoneGeometry = new THREE.DodecahedronGeometry(25 + Math.random() * 15);
                
                // Realistic stone material
                const stoneMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(0.4 + Math.random() * 0.2, 0.35 + Math.random() * 0.15, 0.3 + Math.random() * 0.1),
                    shininess: 5,
                    specular: 0x111111
                });

                const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                stone.position.set(pos.x, 12, pos.z);
                stone.scale.setScalar(pos.scale);
                stone.rotation.set(
                    Math.random() * 0.3,
                    Math.random() * Math.PI * 2,
                    Math.random() * 0.3
                );
                stone.castShadow = true;
                stone.receiveShadow = true;

                stones.push(stone);
                scene.add(stone);
            });
        }

        function createBambooGrove() {
            for (let i = 0; i < 12; i++) {
                const bambooGroup = new THREE.Group();

                // Bamboo culm (main stem)
                const culmGeometry = new THREE.CylinderGeometry(
                    3 + Math.random() * 2,
                    4 + Math.random() * 2,
                    120 + Math.random() * 80,
                    12
                );
                const culmMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(0.4, 0.6, 0.3),
                    shininess: 20,
                    specular: 0x333333
                });

                const culm = new THREE.Mesh(culmGeometry, culmMaterial);
                culm.position.y = 60;
                culm.castShadow = true;
                bambooGroup.add(culm);

                // Bamboo nodes
                for (let j = 0; j < 6; j++) {
                    const nodeGeometry = new THREE.CylinderGeometry(5, 5, 3, 12);
                    const nodeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2d4a1f
                    });
                    const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                    node.position.y = 20 + j * 20;
                    bambooGroup.add(node);
                }

                // Bamboo leaves
                for (let k = 0; k < 8; k++) {
                    const leafGeometry = new THREE.PlaneGeometry(15, 40);
                    const leafMaterial = new THREE.MeshLambertMaterial({
                        color: 0x4a7c32,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });

                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.position.set(
                        (Math.random() - 0.5) * 20,
                        80 + Math.random() * 40,
                        (Math.random() - 0.5) * 20
                    );
                    leaf.rotation.set(
                        Math.random() * 0.5,
                        Math.random() * Math.PI * 2,
                        Math.random() * 0.5
                    );
                    bambooGroup.add(leaf);
                }

                // Position bamboo grove
                const angle = (i / 12) * Math.PI * 2;
                const radius = 400 + Math.random() * 200;
                bambooGroup.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );

                bambooGroup.userData = {
                    swaySpeed: 0.001 + Math.random() * 0.002,
                    swayAmount: 0.02 + Math.random() * 0.03
                };

                bamboo.push(bambooGroup);
                scene.add(bambooGroup);
            }
        }

        function createWaterFeature() {
            // Small pond
            const waterGeometry = new THREE.CircleGeometry(80, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x4a6d7c,
                transparent: true,
                opacity: 0.7,
                shininess: 100,
                specular: 0x888888
            });

            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(300, 2, 200);
            water.receiveShadow = true;
            scene.add(water);

            // Water lilies
            for (let i = 0; i < 3; i++) {
                const lilyGeometry = new THREE.CircleGeometry(12, 8);
                const lilyMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2d5016
                });

                const lily = new THREE.Mesh(lilyGeometry, lilyMaterial);
                lily.rotation.x = -Math.PI / 2;
                lily.position.set(
                    300 + (Math.random() - 0.5) * 120,
                    3,
                    200 + (Math.random() - 0.5) * 120
                );
                scene.add(lily);
            }
        }

        function createFallingLeaves() {
            for (let i = 0; i < 20; i++) {
                const leafGeometry = new THREE.PlaneGeometry(8, 12);
                const leafMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.1 + Math.random() * 0.15, 0.6, 0.4),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });

                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    (Math.random() - 0.5) * 1000,
                    200 + Math.random() * 400,
                    (Math.random() - 0.5) * 1000
                );

                leaf.userData = {
                    fallSpeed: 0.5 + Math.random() * 1,
                    swaySpeed: 0.02 + Math.random() * 0.03,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };

                leaves.push(leaf);
                scene.add(leaf);
            }
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Gentle bamboo sway
            bamboo.forEach((bambooGroup, index) => {
                const userData = bambooGroup.userData;
                bambooGroup.rotation.z = Math.sin(time * userData.swaySpeed + index) * userData.swayAmount;
            });

            // Falling leaves animation
            leaves.forEach((leaf, index) => {
                leaf.position.y -= leaf.userData.fallSpeed;
                leaf.position.x += Math.sin(time * leaf.userData.swaySpeed + index) * 0.5;
                leaf.rotation.z += leaf.userData.rotationSpeed;

                // Reset leaf when it falls too low
                if (leaf.position.y < -50) {
                    leaf.position.y = 400 + Math.random() * 200;
                    leaf.position.x = (Math.random() - 0.5) * 1000;
                    leaf.position.z = (Math.random() - 0.5) * 1000;
                }
            });

            // Subtle water ripple
            if (water) {
                const positions = water.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i + 1];
                    const distance = Math.sqrt(x * x + z * z);
                    positions[i + 2] = Math.sin(time * 2 + distance * 0.1) * 0.5;
                }
                water.geometry.attributes.position.needsUpdate = true;
            }

            // Smooth camera movement
            const targetX = mouseX * 100;
            const targetY = 400 + mouseY * 50;

            camera.position.x += (targetX - camera.position.x) * 0.01;
            camera.position.y += (targetY - camera.position.y) * 0.01;

            // Gentle camera drift
            camera.position.x += Math.sin(time * 0.1) * 0.8;
            camera.position.z += Math.cos(time * 0.08) * 1.2;

            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>