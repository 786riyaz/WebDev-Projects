<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OmFlow - Molecular Yoga</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: none;
            z-index: 100;
        }
        h1 { 
            font-size: 4rem; 
            margin-bottom: 1rem;
            font-weight: 300;
            text-align: center;
        }
        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div class="overlay">
        <h1>Energy Flow Visualization</h1>
        <p>See your chakras in molecular harmony</p>
    </div>
    
    <div class="controls">
        <button id="calm-mode">Calm</button>
        <button id="energy-mode">Energy</button>
        <button id="balance-mode">Balance</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // Initialize scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // Camera position
        camera.position.z = 15;
        
        // Particles
        const particleCount = 2000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        // Color palette
        const colorPalette = [
            new THREE.Color(0xff0000), // Root
            new THREE.Color(0xff7f00), // Sacral
            new THREE.Color(0xffff00), // Solar Plexus
            new THREE.Color(0x00ff00), // Heart
            new THREE.Color(0x0000ff), // Throat
            new THREE.Color(0x4b0082), // Third Eye
            new THREE.Color(0x9400d3)  // Crown
        ];
        
        // Initialize particles
        for (let i = 0; i < particleCount; i++) {
            // Position
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 5 + Math.random() * 5;
            
            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = radius * Math.cos(phi);
            positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
            
            // Color based on vertical position (chakras)
            const colorIndex = Math.floor((positions[i * 3 + 1] + radius) / (2 * radius) * colorPalette.length);
            const color = colorPalette[Math.min(colorIndex, colorPalette.length - 1)];
            
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
            
            // Size
            sizes[i] = 0.5 + Math.random() * 1.5;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // Particle material
        const particleMaterial = new THREE.PointsMaterial({
            size: 1,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        // Create particle system
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Energy lines
        const lineGeometry = new THREE.BufferGeometry();
        const lineCount = 100;
        const linePositions = new Float32Array(lineCount * 6);
        
        for (let i = 0; i < lineCount; i++) {
            const startIndex = i * 6;
            const endIndex = startIndex + 3;
            
            // Random start and end points
            linePositions[startIndex] = (Math.random() - 0.5) * 10;
            linePositions[startIndex + 1] = (Math.random() - 0.5) * 10;
            linePositions[startIndex + 2] = (Math.random() - 0.5) * 10;
            
            linePositions[endIndex] = linePositions[startIndex] + (Math.random() - 0.5) * 2;
            linePositions[endIndex + 1] = linePositions[startIndex + 1] + (Math.random() - 0.5) * 2;
            linePositions[endIndex + 2] = linePositions[startIndex + 2] + (Math.random() - 0.5) * 2;
        }
        
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });
        
        const lineSystem = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lineSystem);
        
        // Animation modes
        const modes = {
            calm: { speed: 0.1, scale: 1, colorIntensity: 0.5 },
            energy: { speed: 0.5, scale: 1.5, colorIntensity: 1 },
            balance: { speed: 0.3, scale: 1.2, colorIntensity: 0.8 }
        };
        
        let currentMode = 'calm';
        
        // Set mode function
        function setMode(mode) {
            currentMode = mode;
        }
        
        // Event listeners
        document.getElementById('calm-mode').addEventListener('click', () => setMode('calm'));
        document.getElementById('energy-mode').addEventListener('click', () => setMode('energy'));
        document.getElementById('balance-mode').addEventListener('click', () => setMode('balance'));
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            const mode = modes[currentMode];
            
            // Rotate particle system
            particleSystem.rotation.y += 0.001 * mode.speed;
            
            // Pulsate particles
            const time = Date.now() * 0.001;
            const scale = mode.scale + Math.sin(time) * 0.1;
            particleSystem.scale.set(scale, scale, scale);
            
            // Update line opacity
            lineMaterial.opacity = 0.2 + Math.sin(time) * 0.1 * mode.colorIntensity;
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>