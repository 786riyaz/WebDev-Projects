<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Particle Playground</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }
        .content {
            position: relative;
            z-index: 1;
            color: white;
            padding: 40px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            pointer-events: none;
        }
        .content h1 {
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
            animation: fadeIn 2s ease-in;
            background: linear-gradient(90deg, #ffffff, #a5b4fc, #c7d2fe);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        .content p {
            max-width: min(800px, 90vw);
            font-size: clamp(1rem, 1.5vw, 1.3rem);
            line-height: 1.6;
            opacity: 0.9;
            animation: fadeIn 3s ease-in;
            margin-bottom: 2rem;
        }
        .controls {
            pointer-events: auto;
            background: rgba(15, 23, 42, 0.7);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }
        button {
            background: rgba(124, 58, 237, 0.7);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        button:hover {
            background: rgba(139, 92, 246, 0.9);
            transform: translateY(-2px);
        }
        .stats {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .pulse {
            animation: pulse 3s infinite;
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    <div class="content">
        <h1>Cosmic Particle Playground</h1>
        <p>Interact with this quantum particle simulation. Move your cursor to influence particle behavior, click/tap to create energy bursts, and experiment with different modes using the controls below.</p>
        
        <div class="controls">
            <button id="gravity-btn">Toggle Gravity</button>
            <button id="attract-btn">Toggle Attraction</button>
            <button id="chaos-btn">Chaos Mode</button>
            <button id="reset-btn">Reset Simulation</button>
            <button id="color-btn">Change Color Scheme</button>
            <button id="particle-btn">Add Particles</button>
        </div>
        
        <p class="pulse">Try dragging with your mouse/finger for vortex effects!</p>
    </div>
    <div class="stats" id="stats">
        <div>Particles: <span id="particle-count">0</span></div>
        <div>FPS: <span id="fps-counter">0</span></div>
        <div>Mode: <span id="mode-display">Default</span></div>
    </div>

    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const statsElement = document.getElementById('stats');
        const fpsCounter = document.getElementById('fps-counter');
        const particleCountElement = document.getElementById('particle-count');
        const modeDisplay = document.getElementById('mode-display');

        // Initialize canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Simulation settings
        const settings = {
            gravity: false,
            attraction: false,
            chaos: false,
            colorScheme: 0,
            particleCount: Math.min(Math.floor(window.innerWidth * window.innerHeight / 3000), 1000),
            baseSpeed: 0.5,
            maxRadius: 4,
            minRadius: 1,
            mouseEffectDistance: 150,
            connectionDistance: 120,
            repulsionForce: 0.5,
            gravityForce: 0.05,
            chaosFactor: 0.2,
            trailLength: 40
        };

        // Color schemes
        const colorSchemes = [
            ['255,255,255', '147,197,253', '251,191,251', '147,253,213'], // Original
            ['255,223,186', '255,179,186', '255,223,186', '186,225,255'], // Pastel
            ['255,107,107', '255,159,67', '255,206,92', '46,213,115'], // Vibrant
            ['162,155,254', '108,92,231', '213,128,255', '254,121,143'], // Neon
            ['194,255,194', '255,194,194', '194,194,255', '255,255,194'], // Soft
            ['255,0,110', '131,56,236', '58,134,255', '0,212,255'] // Gradient
        ];

        // Particle system
        const particles = [];
        const burstParticles = [];
        const attractionPoints = [];
        let lastAttractionPointTime = 0;

        // Pointer (mouse/touch) state
        const pointer = {
            x: null,
            y: null,
            active: false,
            lastX: null,
            lastY: null,
            speed: 0,
            trail: [],
            isDragging: false,
            dragStartX: null,
            dragStartY: null,
            vortexPower: 0
        };

        // Performance tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        let lastFpsUpdate = 0;
        let frameTimes = [];

        // Initialize particles
        function initParticles(count = settings.particleCount) {
            // Clear existing particles (except when adding)
            if (count === settings.particleCount) {
                particles.length = 0;
            }
            
            for (let i = 0; i < count; i++) {
                const colorIndex = Math.floor(Math.random() * colorSchemes[settings.colorScheme].length);
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * (settings.maxRadius - settings.minRadius) + settings.minRadius,
                    baseRadius: Math.random() * (settings.maxRadius - settings.minRadius) + settings.minRadius,
                    color: `rgba(${colorSchemes[settings.colorScheme][colorIndex]}, ${Math.random() * 0.5 + 0.2})`,
                    baseColor: colorSchemes[settings.colorScheme][colorIndex],
                    speedX: (Math.random() * 2 - 1) * settings.baseSpeed,
                    speedY: (Math.random() * 2 - 1) * settings.baseSpeed,
                    originalSpeedX: (Math.random() * 2 - 1) * settings.baseSpeed,
                    originalSpeedY: (Math.random() * 2 - 1) * settings.baseSpeed,
                    lastX: 0,
                    lastY: 0,
                    life: Infinity,
                    mass: Math.random() * 0.5 + 0.5
                });
            }
            particleCountElement.textContent = particles.length;
        }

        // Create burst effect
        function createBurst(x, y, count = 30, power = 3) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * power + power/2;
                const colorIndex = Math.floor(Math.random() * colorSchemes[settings.colorScheme].length);
                burstParticles.push({
                    x,
                    y,
                    radius: Math.random() * 3 + 2,
                    color: `rgba(${colorSchemes[settings.colorScheme][colorIndex]},0.8)`,
                    speedX: Math.cos(angle) * speed,
                    speedY: Math.sin(angle) * speed,
                    life: 60 + Math.random() * 40,
                    decay: 0.93 + Math.random() * 0.04
                });
            }
        }

        // Create attraction point
        function createAttractionPoint(x, y) {
            attractionPoints.push({
                x,
                y,
                strength: 5,
                life: 300
            });
        }

        // Animation loop
        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Calculate FPS (averaged over 10 frames for smoother display)
            frameCount++;
            frameTimes.push(currentTime);
            if (frameTimes.length > 10) frameTimes.shift();
            
            if (currentTime - lastFpsUpdate >= 200) {
                const elapsed = (frameTimes[frameTimes.length-1] - frameTimes[0]) || 1;
                fps = Math.round((frameTimes.length-1) * 1000 / elapsed);
                fpsCounter.textContent = fps;
                lastFpsUpdate = currentTime;
            }

            // Clear canvas with semi-transparent overlay for motion blur effect
            ctx.fillStyle = 'rgba(15, 23, 42, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update pointer trail
            if (pointer.active && pointer.x && pointer.y) {
                pointer.trail.push({ 
                    x: pointer.x, 
                    y: pointer.y, 
                    age: 0,
                    power: pointer.vortexPower
                });
                
                // Calculate pointer speed for effects
                if (pointer.lastX && pointer.lastY) {
                    const dx = pointer.x - pointer.lastX;
                    const dy = pointer.y - pointer.lastY;
                    pointer.speed = Math.sqrt(dx * dx + dy * dy) * 0.5;
                    
                    // Detect dragging for vortex effect
                    if (pointer.speed > 2) {
                        pointer.isDragging = true;
                        pointer.vortexPower = Math.min(pointer.vortexPower + 0.1, 1);
                    } else {
                        pointer.isDragging = false;
                        pointer.vortexPower = Math.max(pointer.vortexPower - 0.02, 0);
                    }
                }
                
                pointer.lastX = pointer.x;
                pointer.lastY = pointer.y;
                
                // Create attraction points while moving (for attraction mode)
                if (settings.attraction && currentTime - lastAttractionPointTime > 50) {
                    createAttractionPoint(pointer.x, pointer.y);
                    lastAttractionPointTime = currentTime;
                }
            }

            // Limit trail length and update age
            pointer.trail = pointer.trail.filter(t => t.age++ < settings.trailLength);
            
            // Draw trail with gradient effect
            for (let i = 0; i < pointer.trail.length; i++) {
                const t = pointer.trail[i];
                const opacity = (1 - t.age / settings.trailLength) * 0.4;
                const size = 8 * (1 - t.age / settings.trailLength) * (1 + t.power);
                
                // Gradient from white to blue based on vortex power
                const gradient = ctx.createRadialGradient(
                    t.x, t.y, 0, 
                    t.x, t.y, size
                );
                gradient.addColorStop(0, `rgba(255,255,255,${opacity * 0.7})`);
                gradient.addColorStop(1, `rgba(100,149,237,${opacity * 0.3})`);
                
                ctx.beginPath();
                ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Update and draw attraction points
            for (let i = attractionPoints.length - 1; i >= 0; i--) {
                const point = attractionPoints[i];
                point.life--;
                
                // Draw pulsing attraction point
                const pulseSize = 10 + Math.sin(currentTime * 0.01) * 5;
                ctx.beginPath();
                ctx.arc(point.x, point.y, pulseSize * (point.life/300), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${point.life/300 * 0.2})`;
                ctx.fill();
                
                if (point.life <= 0) {
                    attractionPoints.splice(i, 1);
                }
            }

            // Update and draw particles
            particles.forEach((particle, index) => {
                // Store previous position for connection lines
                particle.lastX = particle.x;
                particle.lastY = particle.y;

                // Apply gravity if enabled
                if (settings.gravity) {
                    particle.speedY += settings.gravityForce * particle.mass;
                }

                // Apply chaos if enabled
                if (settings.chaos) {
                    particle.speedX += (Math.random() * 2 - 1) * settings.chaosFactor;
                    particle.speedY += (Math.random() * 2 - 1) * settings.chaosFactor;
                }

                // Mouse interaction
                if (pointer.active && pointer.x && pointer.y) {
                    const dx = pointer.x - particle.x;
                    const dy = pointer.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < settings.mouseEffectDistance) {
                        const force = (settings.mouseEffectDistance - distance) / settings.mouseEffectDistance;
                        const angle = Math.atan2(dy, dx);
                        const easing = 1 - Math.pow(1 - force, 3);
                        
                        // Vortex effect when dragging
                        if (pointer.isDragging && pointer.vortexPower > 0.3) {
                            const vortexAngle = angle + Math.PI/2; // Perpendicular angle for vortex
                            const vortexForce = force * pointer.vortexPower * 5;
                            particle.speedX += Math.cos(vortexAngle) * vortexForce;
                            particle.speedY += Math.sin(vortexAngle) * vortexForce;
                        } else {
                            // Standard repulsion
                            const direction = pointer.speed > 10 ? -1 : 1;
                            particle.speedX += direction * Math.cos(angle) * easing * settings.repulsionForce * (1 + pointer.speed/50);
                            particle.speedY += direction * Math.sin(angle) * easing * settings.repulsionForce * (1 + pointer.speed/50);
                        }

                        // Dynamic radius and color
                        particle.radius = Math.min(particle.baseRadius * (1 + easing * 0.8), settings.maxRadius * 2);
                        const [r,g,b] = particle.baseColor.split(',');
                        particle.color = `rgba(${r},${g},${b},${0.3 + easing * 0.7})`;
                    } else {
                        // Return to normal state when far from mouse
                        particle.speedX += (particle.originalSpeedX - particle.speedX) * 0.05;
                        particle.speedY += (particle.originalSpeedY - particle.speedY) * 0.05;
                        particle.radius += (particle.baseRadius - particle.radius) * 0.1;
                        const [r,g,b] = particle.baseColor.split(',');
                        particle.color = `rgba(${r},${g},${b},${Math.random() * 0.3 + 0.2})`;
                    }
                }

                // Attraction to points (if attraction mode is on)
                if (settings.attraction) {
                    attractionPoints.forEach(point => {
                        const dx = point.x - particle.x;
                        const dy = point.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 200) {
                            const force = (200 - distance) / 200 * (point.life/300) * 0.5;
                            const angle = Math.atan2(dy, dx);
                            particle.speedX += Math.cos(angle) * force;
                            particle.speedY += Math.sin(angle) * force;
                        }
                    });
                }

                // Update position
                particle.x += particle.speedX;
                particle.y += particle.speedY;

                // Bounce off walls with damping
                const bounceDamping = 0.8;
                if (particle.x < 0) {
                    particle.speedX = -particle.speedX * bounceDamping;
                    particle.x = 0;
                } else if (particle.x > canvas.width) {
                    particle.speedX = -particle.speedX * bounceDamping;
                    particle.x = canvas.width;
                }
                
                if (particle.y < 0) {
                    particle.speedY = -particle.speedY * bounceDamping;
                    particle.y = 0;
                } else if (particle.y > canvas.height) {
                    particle.speedY = -particle.speedY * bounceDamping;
                    particle.y = canvas.height;
                }

                // Draw particle with glow effect
                const glow = ctx.createRadialGradient(
                    particle.x, particle.y, 0,
                    particle.x, particle.y, particle.radius * 2
                );
                glow.addColorStop(0, particle.color);
                glow.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = glow;
                ctx.fill();
                
                // Draw core of particle
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fillStyle = particle.color.replace(/[\d\.]+\)$/, '1)');
                ctx.fill();
            });

            // Draw connections between particles
            if (!settings.chaos) { // Don't draw connections in chaos mode
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    
                    // Limit connections for performance
                    for (let j = i + 1; j < Math.min(i + 20, particles.length); j++) {
                        const p2 = particles[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < settings.connectionDistance) {
                            const opacity = 1 - distance/settings.connectionDistance;
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = `rgba(255,255,255,${opacity * 0.2})`;
                            ctx.lineWidth = 0.5 + opacity * 1.5;
                            ctx.stroke();
                        }
                    }
                }
            }

            // Update and draw burst particles
            for (let i = burstParticles.length - 1; i >= 0; i--) {
                const p = burstParticles[i];
                
                // Apply gravity to burst particles
                if (settings.gravity) {
                    p.speedY += settings.gravityForce;
                }
                
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                p.radius *= p.decay;
                
                // Draw with glow
                const burstGlow = ctx.createRadialGradient(
                    p.x, p.y, 0,
                    p.x, p.y, p.radius * 3
                );
                burstGlow.addColorStop(0, p.color);
                burstGlow.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * 3, 0, Math.PI * 2);
                ctx.fillStyle = burstGlow;
                ctx.fill();
                
                // Draw core
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color.replace(/[\d\.]+\)$/, '0.8)');
                ctx.fill();

                if (p.life <= 0) {
                    burstParticles.splice(i, 1);
                }
            }
        }

        // Event handlers
        function updatePointer(e, active) {
            pointer.x = e.clientX || (e.touches && e.touches[0].clientX);
            pointer.y = e.clientY || (e.touches && e.touches[0].clientY);
            pointer.active = active;
            
            // Reset drag state if pointer is released
            if (!active) {
                pointer.isDragging = false;
                pointer.vortexPower = 0;
            }
        }

        // UI Controls
        document.getElementById('gravity-btn').addEventListener('click', () => {
            settings.gravity = !settings.gravity;
            modeDisplay.textContent = settings.gravity ? 'Gravity Mode' : 'Default Mode';
        });
        
        document.getElementById('attract-btn').addEventListener('click', () => {
            settings.attraction = !settings.attraction;
            modeDisplay.textContent = settings.attraction ? 'Attraction Mode' : 'Default Mode';
            attractionPoints.length = 0; // Clear existing attraction points
        });
        
        document.getElementById('chaos-btn').addEventListener('click', () => {
            settings.chaos = !settings.chaos;
            modeDisplay.textContent = settings.chaos ? 'Chaos Mode' : 'Default Mode';
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            initParticles();
            settings.gravity = false;
            settings.attraction = false;
            settings.chaos = false;
            modeDisplay.textContent = 'Default Mode';
        });
        
        document.getElementById('color-btn').addEventListener('click', () => {
            settings.colorScheme = (settings.colorScheme + 1) % colorSchemes.length;
            initParticles();
        });
        
        document.getElementById('particle-btn').addEventListener('click', () => {
            const addCount = Math.min(100, 2000 - particles.length);
            if (addCount > 0) {
                initParticles(particles.length + addCount);
            }
        });

        // Window events
        window.addEventListener('mousemove', e => updatePointer(e, true));
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            updatePointer(e, true);
        }, { passive: false });
        
        window.addEventListener('mouseout', () => updatePointer({}, false));
        window.addEventListener('touchend', () => updatePointer({}, false));
        
        window.addEventListener('mousedown', (e) => {
            pointer.dragStartX = e.clientX;
            pointer.dragStartY = e.clientY;
        });
        
        window.addEventListener('mouseup', (e) => {
            // Check if it was a click (not drag)
            if (pointer.dragStartX !== null && 
                Math.abs(e.clientX - pointer.dragStartX) < 5 && 
                Math.abs(e.clientY - pointer.dragStartY) < 5) {
                createBurst(e.clientX, e.clientY);
            }
            pointer.dragStartX = null;
            pointer.dragStartY = null;
        });
        
        window.addEventListener('touchstart', e => {
            e.preventDefault();
            createBurst(e.touches[0].clientX, e.touches[0].clientY, 20, 2);
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particles.forEach(p => {
                p.x = Math.min(p.x, canvas.width);
                p.y = Math.min(p.y, canvas.height);
            });
        });

        // Initialize and start
        initParticles();
        requestAnimationFrame(animate);
    </script>
</body>
</html>