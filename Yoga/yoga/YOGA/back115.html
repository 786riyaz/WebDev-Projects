<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Particle Universe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: radial-gradient(circle at 20% 80%, #0f0f23 0%, #1a1a2e 40%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            cursor: none;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .content {
            position: relative;
            z-index: 2;
            color: white;
            padding: 60px 40px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            pointer-events: none;
        }
        
        .content h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 900;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #ffffff, #a78bfa, #06b6d4, #10b981);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease-in-out infinite, glowPulse 2s ease-in-out infinite alternate;
            text-shadow: 0 0 30px rgba(255,255,255,0.3);
        }
        
        .content p {
            max-width: 700px;
            font-size: clamp(1rem, 2.5vw, 1.4rem);
            line-height: 1.8;
            opacity: 0.85;
            animation: fadeInUp 2s ease-out 0.5s both;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 3;
            pointer-events: all;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 400;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
        }
        
        .control-btn.active {
            background: rgba(167,139,250,0.3);
            border-color: rgba(167,139,250,0.5);
        }
        
        .stats {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            opacity: 0.6;
            font-family: 'Orbitron', monospace;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            z-index: 3;
        }
        
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease;
            backdrop-filter: blur(2px);
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes glowPulse {
            0% { filter: drop-shadow(0 0 10px rgba(255,255,255,0.3)); }
            100% { filter: drop-shadow(0 0 20px rgba(167,139,250,0.5)); }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 0.85;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-wrap: wrap;
                bottom: 20px;
                padding: 0 20px;
            }
            .control-btn {
                padding: 10px 16px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="cursor"></div>
    <canvas id="particle-canvas"></canvas>
    
    <div class="content">
        <h1>PARTICLE UNIVERSE</h1>
        <p>Experience an interactive cosmic symphony where particles dance to your touch. Move to influence gravitational fields, click to create explosive bursts, and watch as digital matter responds to your presence in this mesmerizing quantum playground.</p>
    </div>
    
    <div class="controls">
        <button class="control-btn active" id="gravityMode">Gravity Mode</button>
        <button class="control-btn" id="repelMode">Repel Mode</button>
        <button class="control-btn" id="waveMode">Wave Mode</button>
        <button class="control-btn" id="resetBtn">Reset</button>
    </div>
    
    <div class="stats" id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Mode: <span id="currentMode">Gravity</span></div>
    </div>

    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const cursor = document.getElementById('cursor');
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        
        // Enhanced particle system
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.burstParticles = [];
                this.trails = [];
                this.mode = 'gravity';
                this.pointer = {
                    x: null,
                    y: null,
                    active: false,
                    lastX: null,
                    lastY: null,
                    speed: 0,
                    force: 1
                };
                
                // Enhanced settings
                this.settings = {
                    baseCount: Math.min(300, Math.floor(window.innerWidth * window.innerHeight / 3000)),
                    maxRadius: 4,
                    minRadius: 1,
                    effectDistance: 150,
                    connectionDistance: 120,
                    trailLength: 15,
                    colors: [
                        [255, 255, 255],  // White
                        [167, 139, 250],  // Purple
                        [6, 182, 212],    // Cyan
                        [16, 185, 129],   // Green
                        [251, 191, 36],   // Yellow
                        [239, 68, 68]     // Red
                    ]
                };
                
                this.initParticles();
                this.bindEvents();
            }
            
            initParticles() {
                this.particles = [];
                for (let i = 0; i < this.settings.baseCount; i++) {
                    this.createParticle();
                }
            }
            
            createParticle(x = null, y = null) {
                const colorIndex = Math.floor(Math.random() * this.settings.colors.length);
                const color = this.settings.colors[colorIndex];
                
                const particle = {
                    x: x || Math.random() * canvas.width,
                    y: y || Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    originalVx: (Math.random() - 0.5) * 0.5,
                    originalVy: (Math.random() - 0.5) * 0.5,
                    radius: Math.random() * (this.settings.maxRadius - this.settings.minRadius) + this.settings.minRadius,
                    baseRadius: Math.random() * (this.settings.maxRadius - this.settings.minRadius) + this.settings.minRadius,
                    color: color,
                    alpha: Math.random() * 0.5 + 0.3,
                    baseAlpha: Math.random() * 0.5 + 0.3,
                    age: 0,
                    life: Infinity,
                    trail: [],
                    energy: Math.random() * 0.5 + 0.5
                };
                
                this.particles.push(particle);
                return particle;
            }
            
            createBurst(x, y, intensity = 1) {
                const burstCount = Math.floor(25 * intensity);
                for (let i = 0; i < burstCount; i++) {
                    const angle = (Math.PI * 2 * i) / burstCount + Math.random() * 0.5;
                    const speed = (Math.random() * 8 + 4) * intensity;
                    const colorIndex = Math.floor(Math.random() * this.settings.colors.length);
                    const color = this.settings.colors[colorIndex];
                    
                    this.burstParticles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: Math.random() * 3 + 1,
                        color: color,
                        alpha: 1,
                        life: Math.random() * 60 + 40,
                        maxLife: Math.random() * 60 + 40,
                        decay: Math.random() * 0.02 + 0.01
                    });
                }
            }
            
            updatePointer(x, y, active) {
                if (this.pointer.x !== null && this.pointer.y !== null) {
                    const dx = x - this.pointer.x;
                    const dy = y - this.pointer.y;
                    this.pointer.speed = Math.sqrt(dx * dx + dy * dy);
                }
                
                this.pointer.lastX = this.pointer.x;
                this.pointer.lastY = this.pointer.y;
                this.pointer.x = x;
                this.pointer.y = y;
                this.pointer.active = active;
                this.pointer.force = Math.min(this.pointer.speed / 20, 3);
            }
            
            update() {
                // Update main particles
                this.particles.forEach((particle, index) => {
                    particle.age++;
                    
                    // Mouse interaction based on mode
                    if (this.pointer.active && this.pointer.x !== null) {
                        const dx = this.pointer.x - particle.x;
                        const dy = this.pointer.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.settings.effectDistance && distance > 0) {
                            const force = (this.settings.effectDistance - distance) / this.settings.effectDistance;
                            const angle = Math.atan2(dy, dx);
                            const intensity = force * this.pointer.force * particle.energy;
                            
                            switch (this.mode) {
                                case 'gravity':
                                    particle.vx += Math.cos(angle) * intensity * 0.3;
                                    particle.vy += Math.sin(angle) * intensity * 0.3;
                                    break;
                                case 'repel':
                                    particle.vx -= Math.cos(angle) * intensity * 0.5;
                                    particle.vy -= Math.sin(angle) * intensity * 0.5;
                                    break;
                                case 'wave':
                                    const waveForce = Math.sin(particle.age * 0.1 + distance * 0.05) * intensity;
                                    particle.vx += Math.cos(angle + Math.PI/2) * waveForce * 0.2;
                                    particle.vy += Math.sin(angle + Math.PI/2) * waveForce * 0.2;
                                    break;
                            }
                            
                            // Visual effects
                            particle.radius = particle.baseRadius * (1 + force * 0.8);
                            particle.alpha = particle.baseAlpha + force * 0.4;
                        } else {
                            // Return to normal
                            particle.vx += (particle.originalVx - particle.vx) * 0.05;
                            particle.vy += (particle.originalVy - particle.vy) * 0.05;
                            particle.radius += (particle.baseRadius - particle.radius) * 0.1;
                            particle.alpha += (particle.baseAlpha - particle.alpha) * 0.1;
                        }
                    } else {
                        // Return to normal state
                        particle.vx += (particle.originalVx - particle.vx) * 0.03;
                        particle.vy += (particle.originalVy - particle.vy) * 0.03;
                        particle.radius += (particle.baseRadius - particle.radius) * 0.05;
                        particle.alpha += (particle.baseAlpha - particle.alpha) * 0.05;
                    }
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Boundary collision with energy
                    if (particle.x < 0 || particle.x > canvas.width) {
                        particle.vx *= -0.7;
                        particle.x = Math.max(0, Math.min(particle.x, canvas.width));
                        particle.energy *= 0.9;
                    }
                    if (particle.y < 0 || particle.y > canvas.height) {
                        particle.vy *= -0.7;
                        particle.y = Math.max(0, Math.min(particle.y, canvas.height));
                        particle.energy *= 0.9;
                    }
                    
                    // Add to trail
                    particle.trail.push({ x: particle.x, y: particle.y });
                    if (particle.trail.length > this.settings.trailLength) {
                        particle.trail.shift();
                    }
                    
                    // Energy regeneration
                    if (particle.energy < 1) {
                        particle.energy += 0.001;
                    }
                });
                
                // Update burst particles
                this.burstParticles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.vy += 0.1; // Gravity
                    particle.life--;
                    particle.alpha = particle.life / particle.maxLife;
                    particle.radius *= 0.99;
                    
                    if (particle.life <= 0 || particle.radius < 0.1) {
                        this.burstParticles.splice(index, 1);
                    }
                });
            }
            
            draw() {
                // Clear with fade effect
                ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections first
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const p1 = this.particles[i];
                        const p2 = this.particles[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.settings.connectionDistance) {
                            const opacity = (1 - distance / this.settings.connectionDistance) * 0.3;
                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                            ctx.lineWidth = 0.5;
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw particle trails
                this.particles.forEach(particle => {
                    if (particle.trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
                        
                        for (let i = 1; i < particle.trail.length; i++) {
                            const alpha = (i / particle.trail.length) * particle.alpha * 0.3;
                            ctx.strokeStyle = `rgba(${particle.color.join(',')}, ${alpha})`;
                            ctx.lineWidth = particle.radius * (i / particle.trail.length);
                            ctx.lineTo(particle.trail[i].x, particle.trail[i].y);
                            ctx.stroke();
                            if (i < particle.trail.length - 1) {
                                ctx.beginPath();
                                ctx.moveTo(particle.trail[i].x, particle.trail[i].y);
                            }
                        }
                    }
                });
                
                // Draw main particles
                this.particles.forEach(particle => {
                    // Outer glow
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.radius * 3
                    );
                    gradient.addColorStop(0, `rgba(${particle.color.join(',')}, ${particle.alpha})`);
                    gradient.addColorStop(1, `rgba(${particle.color.join(',')}, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius * 3, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Core particle
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.join(',')}, ${Math.min(particle.alpha * 1.5, 1)})`;
                    ctx.fill();
                });
                
                // Draw burst particles
                this.burstParticles.forEach(particle => {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.join(',')}, ${particle.alpha})`;
                    ctx.fill();
                });
                
                // Draw mouse effect
                if (this.pointer.active && this.pointer.x !== null) {
                    const gradient = ctx.createRadialGradient(
                        this.pointer.x, this.pointer.y, 0,
                        this.pointer.x, this.pointer.y, this.settings.effectDistance
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.pointer.x, this.pointer.y, this.settings.effectDistance, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }
            
            setMode(mode) {
                this.mode = mode;
                document.getElementById('currentMode').textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
            }
            
            reset() {
                this.burstParticles = [];
                this.initParticles();
            }
            
            bindEvents() {
                // Mouse events
                canvas.addEventListener('mousemove', (e) => {
                    this.updatePointer(e.clientX, e.clientY, true);
                    cursor.style.left = e.clientX - 10 + 'px';
                    cursor.style.top = e.clientY - 10 + 'px';
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.updatePointer(null, null, false);
                });
                
                canvas.addEventListener('click', (e) => {
                    this.createBurst(e.clientX, e.clientY, 1.5);
                });
                
                // Touch events
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.updatePointer(touch.clientX, touch.clientY, true);
                }, { passive: false });
                
                canvas.addEventListener('touchend', () => {
                    this.updatePointer(null, null, false);
                });
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.createBurst(touch.clientX, touch.clientY, 1.2);
                }, { passive: false });
                
                // Control buttons
                document.getElementById('gravityMode').addEventListener('click', () => {
                    this.setMode('gravity');
                    this.updateActiveButton('gravityMode');
                });
                
                document.getElementById('repelMode').addEventListener('click', () => {
                    this.setMode('repel');
                    this.updateActiveButton('repelMode');
                });
                
                document.getElementById('waveMode').addEventListener('click', () => {
                    this.setMode('wave');
                    this.updateActiveButton('waveMode');
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                // Resize
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    this.particles.forEach(p => {
                        p.x = Math.min(p.x, canvas.width);
                        p.y = Math.min(p.y, canvas.height);
                    });
                });
            }
            
            updateActiveButton(activeId) {
                document.querySelectorAll('.control-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(activeId).classList.add('active');
            }
        }
        
        // Performance tracking
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        
        // Initialize system
        const particleSystem = new ParticleSystem();
        
        // Animation loop
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                
                // Update stats
                document.getElementById('fps').textContent = fps;
                document.getElementById('particleCount').textContent = 
                    particleSystem.particles.length + particleSystem.burstParticles.length;
            }
            
            particleSystem.update();
            particleSystem.draw();
        }
        
        // Start animation
        animate();
    </script>
</body>
</html>